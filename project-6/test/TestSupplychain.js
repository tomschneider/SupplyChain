// This script is designed to test the solidity smart contract - SuppyChain.sol -- and the various functions within
// Declare a variable and assign the compiled smart contract artifact
var SupplyChain = artifacts.require('SupplyChain')

contract('SupplyChain', function(accounts) {
    // Declare few constants and assign a few sample accounts generated by ganache-cli
    var sku = 1
    var upc = 1
    const productID = sku + upc
    //    const ownerID = accounts[0]
    const originFarmerID = accounts[1]
    const originFarmName = "John Doe"
    const originFarmInformation = "Yarray Valley"
    const originFarmLatitude = "-38.239770"
    const originFarmLongitude = "144.341490"

    const productNotes = "Best beans for Espresso"
    const productPrice = web3.utils.toWei('1', "ether")
    var itemState = 0
    const distributorID = accounts[2]
    const retailerID = accounts[3]
    const consumerID = accounts[4]
//    const emptyAddress = '0x00000000000000000000000000000000000000'

    var bDumpLogs = true;
    var addFarmerLogs;
    var addDistributorLogs;
    var addRetailerLogs;
    var addConsumerLogs;
    var farmerHarvestLogs;
    var farmerProcessLogs;
    var farmerPackLogs;
    var farmerForSaleLogs;
    var distributorBuysLogs;
    var distributorShipsLogs;
    var retailerReceivesLogs;
    var consumerLogs;

    ///Available Accounts
    ///==================
    ///(0) 0x27d8d15cbc94527cadf5ec14b69519ae23288b95
    ///(1) 0x018c2dabef4904ecbd7118350a0c54dbeae3549a
    ///(2) 0xce5144391b4ab80668965f2cc4f2cc102380ef0a
    ///(3) 0x460c31107dd048e34971e57da2f99f659add4f02
    ///(4) 0xd37b7b8c62be2fdde8daa9816483aebdbd356088
    ///(5) 0x27f184bdc0e7a931b507ddd689d76dba10514bcb
    ///(6) 0xfe0df793060c49edca5ac9c104dd8e3375349978
    ///(7) 0xbd58a85c96cc6727859d853086fe8560bc137632
    ///(8) 0xe07b5ee5f738b2f87f88b99aac9c64ff1e0c7917
    ///(9) 0xbd3ff2e3aded055244d66544c9c059fa0851da44

    console.log("ganache-cli accounts used here...")
    console.log("Contract Owner: accounts[0] ", accounts[0])
    console.log("Farmer: accounts[1] ", accounts[1])
    console.log("Distributor: accounts[2] ", accounts[2])
    console.log("Retailer: accounts[3] ", accounts[3])
    console.log("Consumer: accounts[4] ", accounts[4])

    it("TEST ROLE: Add Farmer", async() => {
        {
            const supplyChain = await SupplyChain.deployed();
            // Declare and Initialize a variable for event
            var eventEmitted = false
            // Watch the emitted event add to this role()
            let receipt = supplyChain.FarmerAdded(null, (error, event) => {
                eventEmitted = true;
            });
            addFarmerLogs = receipt.logs;
            // Mark an item as Harvested by calling function harvestItem()
            await supplyChain.addFarmer(originFarmerID);
            let bAdded = await supplyChain.isFarmer(originFarmerID);
            assert.equal(bAdded, true, 'Error: Farmer is not added to Farmer Role')
            assert.equal(eventEmitted, true, 'Error: FarmerAdded event not emitted')
        }
    })
    it("TEST ROLE: Add Distributor", async() => {
        {
            const supplyChain = await SupplyChain.deployed();
            // Declare and Initialize a variable for event
            var eventEmitted = false
            // Watch the emitted event add to this role()
            supplyChain.DistributorAdded(null, (error, event) => {
                eventEmitted = true;
            });

            let receipt = await supplyChain.addDistributor(distributorID);
            addDistributorLogs = receipt.logs;

            let bAdded = await supplyChain.isDistributor(distributorID);
            assert.equal(bAdded, true, 'Error: Distributor is not added to Distributor Role')
            assert.equal(eventEmitted, true, 'Error: DistributorAdded event emitted')
        }
    })
    it("TEST ROLE: Add Retailer", async() => {
        {
            const supplyChain = await SupplyChain.deployed();
            // Declare and Initialize a variable for event
            var eventEmitted = false
            // Watch the emitted event add to this role()
            supplyChain.RetailerAdded(null, (error, event) => {
                eventEmitted = true;
            });
            let receipt = await supplyChain.addRetailer(retailerID);
            addRetailerLogs = receipt.logs;

            let bAdded = await supplyChain.isRetailer(retailerID);
            assert.equal(bAdded, true, 'Error: Retailer is not added to Retailer Role')
            assert.equal(eventEmitted, true, 'Error: RetailerAdded event not emitted')
        }
    })
    it("TEST ROLE: Add Consumer", async() => {
        {
            const supplyChain = await SupplyChain.deployed();
            // Declare and Initialize a variable for event
            var eventEmitted = false
            // Watch the emitted event add to this role()
            supplyChain.ConsumerAdded(null, (error, event) => {
                eventEmitted = true;
            });
            let receipt = await supplyChain.addConsumer(consumerID);
            addConsumerLogs = receipt.logs;

            let bAdded = await supplyChain.isConsumer(consumerID);
            assert.equal(bAdded, true, 'Error: Consumer is not added to Consumer Role')
            assert.equal(eventEmitted, true, 'Error: ConsumerAdded event not emitted')
        }
    })
    it("TEST FARMER: Item is Harvest", async() => {
        {
            const supplyChain = await SupplyChain.deployed()

            let eventEmitted = false
            supplyChain.ItemHarvested(null, (error, event) => {
                eventEmitted = true;
            });

            var actor = originFarmerID;
            let receipt = await supplyChain.harvestItem(
                upc,
                originFarmerID,
                originFarmName,
                originFarmInformation,
                originFarmLatitude,
                originFarmLongitude,
                productNotes, {from: actor});

            farmerHarvestLogs = receipt.logs;

            // Retrieve the just now saved item from blockchain by calling function fetchItem()
            const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
            const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

            // Verify the result set
            assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU')
            assert.equal(resultBufferOne[1], upc, 'Error: Invalid item UPC')
            assert.equal(resultBufferOne[2], actor, 'Error: Owner should be Farmer')
            assert.equal(resultBufferOne[3], originFarmerID, 'Error: Missing or Invalid originFarmerID')
            assert.equal(resultBufferOne[4], originFarmName, 'Error: Missing or Invalid originFarmName')
            assert.equal(resultBufferOne[5], originFarmInformation, 'Error: Missing or Invalid originFarmInformation')
            assert.equal(resultBufferOne[6], originFarmLatitude, 'Error: Missing or Invalid originFarmLatitude')
            assert.equal(resultBufferOne[7], originFarmLongitude, 'Error: Missing or Invalid originFarmLongitude')
            assert.equal(resultBufferTwo[4], 0, 'Error: Invalid item State')
            assert.equal(eventEmitted, true, 'Invalid event emitted')
        }
    })    
    it("TEST FARMER: Item is Processed", async() => {
        {
            const supplyChain = await SupplyChain.deployed()

            var eventEmitted = false
            supplyChain.ItemProcessed(null, (error, event) => {
                eventEmitted = true;
            });

            var actor = originFarmerID;
            let receipt = await supplyChain.processItem(upc, {from: actor})
            farmerProcessLogs = receipt.logs;

            // Retrieve the just now saved item from blockchain by calling function fetchItem()
            const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
            const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

            assert.equal(resultBufferOne[2], actor, 'Error: Farmer should be Owner')
            assert.equal(resultBufferTwo[4], SupplyChain.State.Processed, 'Error: State should be PROCESSED')
            assert.equal(eventEmitted, true, 'Invalid event emitted')
        }
    })    
    it("TEST FARMER: Item is Packed", async() => {
        {
            const supplyChain = await SupplyChain.deployed()

            var eventEmitted = false
            supplyChain.ItemPacked(null, (error, event) => {
                eventEmitted = true;
            });

            var actor = originFarmerID;
            let receipt = await supplyChain.packItem(upc, {from: actor})
            farmerPackLogs = receipt.logs;

            // Retrieve the just now saved item from blockchain by calling function fetchItem()
            const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
            const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

            // Verify the result set
            assert.equal(resultBufferOne[2], actor, 'Error: Farmer should be owner')
            assert.equal(resultBufferTwo[4], SupplyChain.State.Packed, 'Error: State should be PACKED')
            assert.equal(eventEmitted, true, 'Invalid event emitted')
        }
    })    
    it("TEST FARMER: Item is For Sale", async() => {
        {
            const supplyChain = await SupplyChain.deployed()

            var eventEmitted = false
            supplyChain.ItemForSale(null, (error, event) => {
                eventEmitted = true;
            });

            var actor = originFarmerID;
            let receipt = await supplyChain.sellItem(upc, productPrice, {from: actor});
            farmerForSaleLogs = receipt.logs;

            const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc);
            const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc);

            assert.equal(resultBufferOne[2], actor, 'Error: Owner should still be Farmer ownerID')
            assert.equal(resultBufferTwo[3], productPrice, 'Error: Expected Price is Wrong')
            assert.equal(resultBufferTwo[4], SupplyChain.State.ForSale, 'Error: State should be FOR SALE')
            assert.equal(eventEmitted, true, 'Invalid event emitted')
        }
    })    
    it("TEST DISTRIBUTOR: Item is Sold", async() => {
        {
            const supplyChain = await SupplyChain.deployed()

            var eventItemSoldEmitted = false;
            supplyChain.ItemSold(null, (error, event) => {
                eventItemSoldEmitted = true;
            });

            var eventRefundSentEmitted = false;
            supplyChain.RefundSent(null, (error, event) => {
                eventRefundSentEmitted = true;
            });

            var eventPaymentSentEmitted = false
            supplyChain.PaymentSent(null, (error, event) => {
                eventPaymentSentEmitted = true;
            });

            var actor = distributorID;
            var payPrice = web3.utils.toWei('2', "ether")
            let receipt = await supplyChain.buyItem(upc, {from: actor, value: payPrice});
            distributorBuysLogs = receipt.logs;

            const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
            const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

            assert.equal(resultBufferOne[2], actor, 'Error: Distributor should be owner')
            assert.equal(resultBufferTwo[4], SupplyChain.State.Sold, 'Error: State should be SOLD')
            assert.equal(eventItemSoldEmitted, true, 'Did not receive ItemSold Event')
            assert.equal(eventRefundSentEmitted, true, 'Did not receive RefundSent Event')
            assert.equal(eventPaymentSentEmitted, true, 'Did not receive PaymentSent Event')
        }
    })
    it("TEST DISTRIBUTOR: Item is Shipped", async() => {
        {
            const supplyChain = await SupplyChain.deployed()

            var eventEmitted = false;
            supplyChain.ItemShipped(null, (error, event) => {
                eventEmitted = true;
            });

            var actor = distributorID;
            let receipt = await supplyChain.shipItem(upc, {from: actor})
            distributorShipsLogs = receipt.logs;

            const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
            const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

            assert.equal(resultBufferOne[2], actor, 'Error: Distributor should still be owner')
            assert.equal(resultBufferTwo[4], SupplyChain.State.Shipped, 'Error: State should be SHIPPED')
            assert.equal(eventEmitted, true, 'ItemShipped event emitted')
        }
    })

    it("TEST RETAILER: Item is Received", async() => {
        {
            const supplyChain = await SupplyChain.deployed()

            var eventEmitted = false;
            supplyChain.ItemReceived(null, (error, event) => {
                eventEmitted = true;
            });

            var actor = retailerID;
            let receipt = await supplyChain.receiveItem(upc, {from: actor});
            retailerReceivesLogs = receipt.logs;

            const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
            const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

            assert.equal(resultBufferOne[2], actor, 'Error: Distributor should still be owner')
            assert.equal(resultBufferTwo[4], SupplyChain.State.Received, 'Error: State should be RECEIVED')
            assert.equal(eventEmitted, true, 'ItemReceived event not emitted')
            }
     })

    it("TEST CONSUMER: Item is Purchased", async() => {

        {
        const supplyChain = await SupplyChain.deployed()

        var eventEmitted = false;
        supplyChain.ItemPurchased(null, (error, event) => {
            eventEmitted = true;
        });

        var actor = consumerID;
        let receipt = await supplyChain.purchaseItem(upc, {from: actor});

        consumerLogs = receipt.logs;

        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

        assert.equal(resultBufferOne[2], actor, 'Error: Consumer should still be owner')
        assert.equal(resultBufferTwo[4], SupplyChain.State.Purchased, 'Error: State should be PURCHASED')
        assert.equal(eventEmitted, true, 'ItemPurchased event not emitted')
    }
        
    })    

    it("TEST fetchItemBufferOne()", async() => {
        {
            const supplyChain = await SupplyChain.deployed()
            const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
            assert.equal(resultBufferOne[0], sku, 'Error: sku')
            assert.equal(resultBufferOne[1], upc, 'Error: upc')
            assert.equal(resultBufferOne[2], consumerID, 'Error: ownerID should be Consumer ID')
            assert.equal(resultBufferOne[3], originFarmerID, 'Error: originFarmerID')
            assert.equal(resultBufferOne[4], originFarmName, 'Error: originFarmName')
            assert.equal(resultBufferOne[5], originFarmInformation, 'Error: originFarmInformation')
            assert.equal(resultBufferOne[6], originFarmLatitude, 'Error: originFarmLatitude')
            assert.equal(resultBufferOne[7], originFarmLongitude, 'Error: originFarmLongitude')
            assert.equal(resultBufferOne[8], productID, 'Error: productID')
        }
    })

    it("TEST fetchItemBufferTwo()", async() => {
        {
            const supplyChain = await SupplyChain.deployed()
            const resultBufferOne = await supplyChain.fetchItemBufferTwo.call(upc)
            assert.equal(resultBufferOne[0], sku, 'Error: sku')
            assert.equal(resultBufferOne[1], upc, 'Error: upc')
            assert.equal(resultBufferOne[2], productNotes, 'Error: productNotes')
            assert.equal(resultBufferOne[3], productPrice, 'Error: productPrice')
            assert.equal(resultBufferOne[4], SupplyChain.State.Purchased, 'Error: State should be Purchased')
            assert.equal(resultBufferOne[5], distributorID, 'Error: distributorID')
            assert.equal(resultBufferOne[6], retailerID, 'Error: retailerID')
            assert.equal(resultBufferOne[7], consumerID, 'Error: consumerID')
        }


    })
    it("DUMP LOGS", async() => {
        if (bDumpLogs) {
            console.log('========================');
            console.log("Add Farmer Logs")
            console.log(addFarmerLogs);

            console.log('========================');
            console.log("Add Distributor Logs")
            console.log(addDistributorLogs);

            console.log('========================');
            console.log("Add Retailer Logs")
            console.log(addRetailerLogs);

            console.log('========================');
            console.log("Add Consumer Logs")
            console.log(addConsumerLogs);

            console.log('========================');
            console.log("Farmer Harvest Logs")
            console.log(farmerHarvestLogs);

            console.log('========================');
            console.log("Farmer Process Logs")
            console.log(farmerProcessLogs);

            console.log('========================');
            console.log("Farmer Pack Logs")
            console.log(farmerPackLogs);

            console.log('========================');
            console.log("Farmer For Sale Logs")
            console.log(farmerForSaleLogs);

            console.log('========================');
            console.log("Distributor Buys Logs")
            console.log(distributorBuysLogs);

            console.log('========================');
            console.log("Distributor Ships Logs")
            console.log(distributorShipsLogs);

            console.log('========================');
            console.log("Retailer Receives Logs")
            console.log(retailerReceivesLogs);

            console.log('========================');
            console.log("Consumer: purchaseItem logs")
            console.log(consumerLogs);
        }
    })
});

